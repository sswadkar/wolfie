import os
import json
import boto3

class AthenaQueryHandler:
    """
    Generates SQL based on a user prompt using the same Bedrock LLM calls
    as your main Lambda, then executes the SQL via Athena.
    """

    DB = "product_db"
    OUTPUT_LOCATION = "s3://llmchatbotkb/Unsaved/"

    PRODUCT_HEADERS = (
        "proprietary_name,ndc_product_code,product_type_name,product_kits_flag,"
        "strength,dosage_name,market_category_name,market_status,product_market_status,"
        "fda_approved,product_fee_status,market_start_date,market_end_date,"
        "discontinue_date,submission_date,labeler_firm_name,labeler_firm_duns,"
        "labeler_ndc_code,registrant_firm_name,registrant_firm_duns,document_num,"
        "doc_type_code,applicant_firm_name,application_number"
    )

    def __init__(self, access_key: str = None, secret_key: str = None):
        self.AWS_ACCESS_KEY = access_key or os.getenv("AWS_ACCESS_KEY_BOTO3")
        self.AWS_SECRET_KEY = secret_key or os.getenv("AWS_SECRET_KEY_BOTO3")

        self.region = "us-east-1"
        
        self.inference_profile_arn = os.getenv("INFERENCE_PROFILE_ARN")

        self.bedrock = boto3.client(
            "bedrock-runtime",
            region_name=self.region,
            aws_access_key_id=self.AWS_ACCESS_KEY,
            aws_secret_access_key=self.AWS_SECRET_KEY
        )
        self.athena = boto3.client(
            "athena",
            region_name=self.region,
            aws_access_key_id=self.AWS_ACCESS_KEY,
            aws_secret_access_key=self.AWS_SECRET_KEY
        )

    def bedrock_query_llm(self, prompt: str) -> str:
        try:
            native_request = {
                "anthropic_version": "bedrock-2023-05-31",
                "max_tokens": 512,
                "temperature": 0.5,
                "messages": [
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt}
                        ],
                    }
                ],
            }

            response = self.bedrock.invoke_model(
                modelId=self.inference_profile_arn,
                body=json.dumps(native_request),
            )
            data = json.loads(response["body"].read().decode("utf-8"))

            returned_content = data.get("content", [])
            
            # If the model returns a list of chunks, combine them
            if isinstance(returned_content, list):
                combined_text = []
                for chunk in returned_content:
                    # Usually chunk has the form {"type": "text", "text": "..."}
                    if isinstance(chunk, dict) and "text" in chunk:
                        combined_text.append(chunk["text"])
                # Join all chunk texts into one string
                final_text = " ".join(combined_text)
                return final_text if final_text.strip() else "No response generated by LLM"
            
            # Otherwise, if content is a single string
            elif isinstance(returned_content, str):
                return returned_content.strip() or "No response generated by LLM"

            # If content is something else, fallback
            return "No response generated by LLM"
        
        except Exception as e:
            print(f"Bedrock Query Error: {e}")
            return "Error generating SQL with LLM"

    def generate_query(self, user_prompt: str) -> str:
        """
        Calls the Bedrock LLM to produce an SQL statement from a user prompt.
        The system instructions ensure only valid Athena SQL is returned.
        """
        
        details = (
            "If you believe the question doesn’t relate to the product database, return nothing. "
            "Only generate an SQL query that strictly follows the rules below:\n"
            "1. Respect Athena syntax: All columns must comply with their data types.\n"
            "2. Use LIKE instead of '=' for searching text columns, wrap with '%...%'.\n"
            f"3. Only select from the product_info table with columns:\n{self.PRODUCT_HEADERS}\n"
            "4. Return only the SQL (no extra commentary). End with a semicolon.\n"
            "User prompt:\n"
        )

        llm_input = details + user_prompt
        response_text = self.bedrock_query_llm(llm_input).strip()

        # Ensure it ends with a semicolon
        if not response_text.endswith(";"):
            response_text += ";"

        return response_text

    def query_athena(self, sql_query: str):
        """
        Runs the given SQL query in Athena and returns (results_string, error).
        If 'error' is not None, 'results_string' may be None.
        """
        try:
            response = self.athena.start_query_execution(
                QueryString=sql_query,
                QueryExecutionContext={"Database": self.DB},
                ResultConfiguration={"OutputLocation": self.OUTPUT_LOCATION},
            )

            query_execution_id = response["QueryExecutionId"]
            
            # Wait until query completes
            while True:
                status_resp = self.athena.get_query_execution(QueryExecutionId=query_execution_id)
                status = status_resp["QueryExecution"]["Status"]["State"]
                
                if status in ["SUCCEEDED", "FAILED", "CANCELLED"]:
                    break
                
                import time
                time.sleep(2)

            if status == "SUCCEEDED":
                # Fetch results
                result_response = self.athena.get_query_results(QueryExecutionId=query_execution_id)
                rows = result_response["ResultSet"]["Rows"]

                # If only 1 row, that's the header row → no actual data
                if len(rows) <= 1:
                    return {
                        "response": None, 
                        "error": "No product was found.",
                        "sql_query": sql_query
                    }

                # Build a CSV-like output from the row data
                output = []
                for row in rows[1:]:  # skip header row
                    values = [col.get("VarCharValue", "NULL") for col in row["Data"]]
                    output.append(",".join(values))
                
                return {
                    "response": "\n".join(output),
                    "error": None,
                    "sql_query": sql_query
                }
            else:
                reason = status_resp["QueryExecution"]["Status"].get("StateChangeReason", "Unknown error")
                return {
                    "response": None,
                    "error": f"Query {status}: {reason}",
                    "sql_query": sql_query
                }

        except Exception as e:
            return {
                "response": None,
                "error": str(e),
                "sql_query": sql_query
            }
            
